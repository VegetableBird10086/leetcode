ZZL:
执行用时：296 ms, 在所有 C++ 提交中击败了49.83%的用户
内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.41%的用户

思路：动态规划
状态：dp[i][j]表示i~j这些是否是回文串
方程：dp[i][j]=(dp[i+1][j-1]&(s[i]==s[j]))
i+1=j时特殊判断即可
这里要注意上次状态i增加，j减小。所以i是从大到小遍历，j是从小到大遍历
剩余的方法研究中...
class Solution {
public:
    string longestPalindrome(string s) {
        bool dp[1001][1001];
        int size = s.size();
        int ans=1,l=0,r=0;
        for(int i=0;i<size;i++)
            dp[i][i]=1;
        for(int i=size-2;i>=0;i--){
            for(int j=i+1;j<size;j++){
                if(i+1==j)
                    dp[i][j]=(s[i]==s[j]);
                else
                    dp[i][j]=(dp[i+1][j-1]&(s[i]==s[j]));
                if(dp[i][j]&&j-i+1>ans){
                    ans = j-i+1;
                    l=i;r=j;
                }
            }
        }
        return s.substr(l,ans);
    }
};

