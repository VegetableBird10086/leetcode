ZZL:
执行用时：40 ms, 在所有 C++ 提交中击败了94.16%的用户
内存消耗：86.9 MB, 在所有 C++ 提交中击败了94.09%的用户
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
我只是记录以下思路，这里还是建议看leetcode官方解法~

考虑到题目是log级的复杂度，所以本题会使用到二分查找
当数组长度为奇数时，其中位数实质就是第（size+1）/2个数的值
当数组长度为偶数时，其中位数实质就是第（size/2）个和（size/2+1）个的平均值
这里的计数是从1开始
因此，本题实质上就转化成了一个求第k个数的问题
每次比较两个数组中索引为k/2-1，如果先不考虑边界问题，即索引k/2-1对于两个数组都未越界
那么很容易发现，该索引下两个数组中较小的那个一定不是第k个数
这是因为较小的那个数左侧有k/2-1个数(索引是从0开始的)，较大的那个数左侧也有k/2-1个数
即较小的那个数最大是第k-1个数，所以可以将该数之前的数全部排除
那么求第k个数的问题又转化成了求第（k-排除个数）个数问题
当然，两数比较还会有相等的情况
但是，相等仍然可以看作小于，这对答案是不影响的

现在考虑以下边界问题，也就是k/2-1越界问题
如果是索引大于等于数组的规模，这时只能用数组中最后一个元素去比较
可以发现，如果此时比较结果是数组中最后一个元素较小，那么中位数一定在另一个数组中
如果不是，按之前步骤处理即可

另一部分注释在代码中
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class Solution {
public:
    // 求第k个数
    double getKthElement(vector<int>& nums1, vector<int>& nums2, int K){
    /*
        * 这里会出现两种索引: last_index now_index
        * last_index表征的是当前数组中的起始索引-1，now_index表征的是当前要比较大小的元素索引
        * 举个例子 nums1:1,2,3  nums2:2,3,4
        * 起始索引是0，那么last_index1和last_index2都是-1
        * 如果我们求第3个数，第一次now_index1=now_index2=0
        * nums1[0]<nums2[0]，所以nums1中(last_index1,now_index1]均被排除
        * 对于nums1中的起始索引就变成了1，所以last_index1会变成0（注意减1）
        * 而nums2中的起始索引不变
    */
        int last_index1=-1,last_index2=-1;
        int m=nums1.size(),n=nums2.size();
        while(1){
        /*
            * 这里处理边界情况
            * last_index到达数组边界，只有两种情况：1.数组为空 2.在更新时到达边界
            * 这里更新只能是数组边界值较小，否则last_index不会更新为边界索引
            * 而如果是数组为空，则第一次就会直接到达数组边界
            * 但无论是上面那种情况，第k个数不可能存在于到达边界的数组中(可能存在等于的情况，但是不影响结果)
            * 所以可以直接从另一个数组中寻找
            * 也就是从另一个数组中的起始索引向后寻找k个数
            * 也即last_index+k（注意last_index是起始索引减1
        */
            if(last_index1==m-1)
                return nums2[last_index2+K];
            if(last_index2==n-1)
                return nums1[last_index1+K];
        /*
            * 如果是k==1，即求当前第一个数
            * 取二者中较小的一个即可
        */       
            if(K==1)
                return min(nums1[last_index1+1],nums2[last_index2+1]);
        /*
            * 取当前k/2-1的元素，注意是在不断的删除元素
            * 所以是last_index+k/2
        */         
            int now_index1=min(last_index1+K/2,m-1),now_index2=min(last_index2+K/2,n-1);
            // 更新k值
            if(nums1[now_index1]<nums2[now_index2]){
                K-=now_index1-last_index1;
                last_index1=now_index1;
            }
            else{
                K-=now_index2-last_index2;
                last_index2=now_index2;
            }
        }
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int total_length=nums1.size()+nums2.size();
        if(total_length&1)
            return getKthElement(nums1,nums2,(total_length+1)>>1);
        else
            return (getKthElement(nums1,nums2,total_length >>1)+getKthElement(nums1,nums2,(total_length >>1)+1))/2.0;
    }
};
