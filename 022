ZZL:
执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户
内存消耗：11.4 MB, 在所有 C++ 提交中击败了75.66%的用户
class Solution {
public:
    vector<string> ans;
    string parenthesis;
    void DFS(int n, int left, int right){
        if(right==n){
            ans.push_back(parenthesis);
            return;
        }
        if(left<n){
            parenthesis.push_back('(');
            DFS(n,left+1,right);
            parenthesis.pop_back();
        }
        if(right<left){
            parenthesis.push_back(')');
            DFS(n,left,right+1);
            parenthesis.pop_back();
        }
    }
    vector<string> generateParenthesis(int n) {
        DFS(n,0,0);
        return ans;
    }
};
题解中有一个使用了动态规划，思路挺巧妙的，可以看看。
