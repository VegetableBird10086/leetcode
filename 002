ZZL:
执行用时：40 ms, 在所有 C++ 提交中击败了87.82%的用户
内存消耗：69 MB, 在所有 C++ 提交中击败了99.30%的用户
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 答案用l1储存储存
        ListNode* ans = l1;
        // 进位 运算结果
        int carry_bit = 0, val = 0;
        while(l2!= nullptr || carry_bit){
            if(l2 != nullptr)
                val = l1->val + l2->val + carry_bit;
            else
                val = l1->val + carry_bit;
            carry_bit = val / 10;
            val %= 10;
            l1->val = val;
            if(l2!=nullptr)
                l2 = l2->next;
            if(l1->next == nullptr&&(l2!=nullptr||carry_bit))
                l1->next = new ListNode;
            l1 = l1->next;
        }
        return ans;
    }
};


LSY：
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode*head=NULL;      //头指针为空
        ListNode*tail=NULL;      //尾指针为空
        int x=0;      //表示进位
        while(l1||l2)      //只要两个链表均非空
        {
            int n1=l1?l1->val:0;      //链表的第一个元素
            int n2=l2?l2->val:0;      //另一个链表的第一个元素
            int sum=n1+n2+x;      //两个数值以及进位的和
            if(!head)      //如果头指针为空
            {
                head=tail=new ListNode(sum%10);      //头和尾均为和的个位
            }
            else
            {
                tail->next=new ListNode(sum%10);
                tail=tail->next;      //修改尾指针
            }
            x=sum/10;      //修改进位的数值
            if(l1)      //链表1非空
            l1=l1->next;      //指向下一个元素
            if(l2)      //链表2非空
            l2=l2->next;      //指向下一个元素
        }
        if(x>0)      //如果仍有进位
        tail->next=new ListNode(x);      //添加新的结点
        return head;
    }
};


LXT：
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int tab=0;//表示进位
        ListNode* current1=l1;
        ListNode* current2=l2;
        while(current1->next!=NULL||current2->next!=NULL) {//把两个链表补的一样长
            if(current1->next==NULL) {
                current1->next=new ListNode();
            }
            else if(current2->next==NULL) {
                current2->next=new ListNode();
            }
            current1->val=current1->val+current2->val+tab;
            if(current1->val>9) {
                tab=1;
                current1->val=current1->val-10;
            } 
            else tab=0;
            current1=current1->next;
            current2=current2->next;   
        }
        current1->val=current1->val+current2->val+tab;//最后一位的计算
        if(current1->val>9) {
            tab=1;
            current1->val=current1->val-10;
            current1->next=new ListNode(1);//进位1
        } 
        else tab=0;
        return l1;
    }
};
