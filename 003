ZZL:
执行用时：4 ms, 在所有 C++ 提交中击败了98.38%的用户
内存消耗：6.8 MB, 在所有 C++ 提交中击败了97.58%的用户
class Solution {
public:
    // 本题做法：尺取法
    int lengthOfLongestSubstring(string s) {
        // 建立集合
        bool hash[256]={0};
        int ans=0,nowLength=0;
        // 双指针
        int left=0,right=0;
        while(right<s.size()){
            // 当右指针的所指元素已经存在在集合中时
            while(hash[s[right]]){
                // 左指针收缩 
                hash[s[left++]]=false;
                nowLength--;
            }
            nowLength++;
            ans = max(nowLength,ans);
            hash[s[right]]=true;   
            right++;
        }
        return ans;
    }
};


LSY：
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() == 0) return 0;
        unordered_set<char> lookup;      //集合记录每个字符
        int maxStr = 0;
        int left = 0;      //左指针为0
        for (int i = 0; i < s.size(); i++) {
            while (lookup.find(s[i]) != lookup.end()) {
                lookup.erase(s[left]);      //滑块移动，最左边元素出集合
                left++;
            }
            maxStr = max(maxStr, i - left + 1);
            lookup.insert(s[i]);
        }
        return maxStr;
    }
};


LXT:
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        stack<int> result;//保存结果的最大值
        result.push(0);
        if(s.length()==0) return 0;//序列为空，直接返回结果
        int tail,i,head=0,tab=1;//头尾两指针，指向当前所测试子序列
        for(tail=1;tail<s.length();tail++) {//
            for(i=1;i<=tail-head;i++) {
                if(s[tail]==s[tail-i]) {//有重复时
                    if(tail==s.length()-1) tab=0;//到结尾时无重复，标记
                    if(result.top()<tail-head) {//比之前子序列长度大，则保存入栈
                    result.push(tail-head); 
                    }                    
                    head++;tail--;
                    break; 
                }
            }
        }
        if(tab==1&&result.top()<tail-head) {//最后结尾时的无重复序列
            result.push(tail-head);
        };
        int p=result.top();
        return p;
    }
};
